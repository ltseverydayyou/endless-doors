local S = function(n)
	local s = game:GetService(n);
	return cloneref and cloneref(s) or s;
end;
local GAME_IDS = {
	3927488489,
	5927366432,
	6023940812
};
local PLACE_IDS = {
	10891480658,
	16810788519,
	17324650150,
	17639491565,
	17594182379
};
if not (table.find(GAME_IDS, game.GameId) and table.find(PLACE_IDS, game.PlaceId)) then
	return;
end;
local pOLD, pEPIC, pREN, pEMARC, pCLASS = 10891480658, 16810788519, 17324650150, 17639491565, 17594182379;
local Players = S("Players");
local TweenService = S("TweenService");
local RunService = S("RunService");
local UIS = S("UserInputService");
local PPromptService = S("ProximityPromptService");
local SoundService = S("SoundService");
local LocalPlayer = Players.LocalPlayer;
local IsOnMobile = (function()
	local platform = UIS:GetPlatform();
	if platform == Enum.Platform.IOS or platform == Enum.Platform.Android or platform == Enum.Platform.AndroidTV or platform == Enum.Platform.Chromecast or platform == Enum.Platform.MetaOS then
		return true;
	end;
	if platform == Enum.Platform.None then
		return UIS.TouchEnabled and (not (UIS.KeyboardEnabled or UIS.MouseEnabled));
	end;
	return false;
end)();
local GameFolder = workspace:WaitForChild("Game");
local Values = GameFolder:WaitForChild("Values");
local Rooms = GameFolder:WaitForChild("Rooms");
local Entities = GameFolder:WaitForChild("Entities");
local currentCamera = workspace.CurrentCamera;
local brightLoop, antiAFKConn, fovLockConn, cameraConn, infJumpConn, mobHoldConn, mobDownConn, mobUpConn;
local overCon, lurkCon, watchCon, flowCon, abyssCon, takerCon, chaseCon;
local greedActive = false;
local scriptRunning = true;
local activeConnections = {};
local function trackConnection(conn)
	if conn then
		activeConnections[(#activeConnections) + 1] = conn;
	end;
	return conn;
end;
(getgenv()).speed = tonumber((getgenv()).speed) or 16;
(getgenv()).jump = tonumber((getgenv()).jump) or 30;
(getgenv()).fov = tonumber((getgenv()).fov) or 70;
(getgenv()).promptDelay = tonumber((getgenv()).promptDelay) or 0;
(getgenv()).autoFarm = (getgenv()).autoFarm or false;
(getgenv()).autoHeal = (getgenv()).autoHeal or false;
local decalID = 95434351872718;
local function GuiRoot()
	return gethui and gethui() or (S("CoreGui")):FindFirstChild("RobloxGui") or S("CoreGui") or LocalPlayer:WaitForChild("PlayerGui");
end;
if not game:IsLoaded() then
	local m = Instance.new("Message", GuiRoot());
	m.Text = "waiting for the game to load";
	game.Loaded:Wait();
	m:Destroy();
end;
local function rootOf(c)
	if c:IsA("Player") then
		c = c.Character;
	end;
	return c and (c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("UpperTorso") or c:FindFirstChild("Torso") or c:FindFirstChild("LowerTorso") or c:FindFirstChildWhichIsA("BasePart"));
end;
local function charValStr(ctn, nm)
	local ch = LocalPlayer.Character;
	local o = ch and ch:FindFirstChild(ctn) and ch[ctn]:FindFirstChild(nm);
	return o and tostring(o.Value);
end;
local function tpToDoor()
	local r = Rooms:FindFirstChild("Room" .. Values.RoomsNumber.Value);
	if not (r and r:FindFirstChild("Door")) then
		return;
	end;
	local rn = r:GetAttribute("RoomName");
	if typeof(rn) == "string" and rn == "ClockRoom" then
		return;
	end;
	if greedActive then
		local dist, tendRoot = nearestTendrilsDistance();
		if dist < SAFE_TENDRILS_DIST then
			local ch = LocalPlayer.Character;
			local myRoot = rootOf(ch);
			if myRoot and tendRoot then
				local dir = myRoot.Position - tendRoot.Position;
				if dir.Magnitude > 0 then
					dir = dir.Unit;
					local offset = dir * (SAFE_TENDRILS_DIST + 5);
					ch:PivotTo(CFrame.new(tendRoot.Position + offset));
				end;
			end;
			return;
		end;
	end;
	LocalPlayer.Character:PivotTo(r.Door:GetPivot());
end;
local function tpToKey()
	local ch = LocalPlayer.Character;
	local hk = ch and ch:FindFirstChild("Values") and ch.Values:FindFirstChild("HasKey");
	if hk and hk.Value then
		return;
	end;
	local r = Rooms:FindFirstChild("Room" .. Values.RoomsNumber.Value);
	if not r then
		return;
	end;
	local rn = r:GetAttribute("RoomName");
	if typeof(rn) == "string" and rn == "ClockRoom" then
		return;
	end;
	for _, d in ipairs(r:GetDescendants()) do
		if d:IsA("BasePart") and d.Name:lower() == "roomkey" and d.Parent.Name:lower() ~= "door" then
			LocalPlayer.Character:PivotTo(d:GetPivot());
			break;
		end;
	end;
end;
local function tpToLever()
	local r = Rooms:FindFirstChild("Room" .. Values.RoomsNumber.Value);
	if not r then
		return;
	end;
	local rn = r:GetAttribute("RoomName");
	if typeof(rn) == "string" and rn == "ClockRoom" then
		return;
	end;
	for _, d in ipairs(r:GetDescendants()) do
		if (d:IsA("BasePart") or d:IsA("Model")) and d.Name:lower() == "gatelever" then
			LocalPlayer.Character:PivotTo(d:GetPivot());
			break;
		end;
	end;
end;
local function disableRagdoll()
	local t = LocalPlayer.Character:FindFirstChild("RagdollTrigger");
	if t then
		t.Value = false;
	end;
end;
local function bindFOV(cam)
	if fovLockConn then
		fovLockConn:Disconnect();
		fovLockConn = nil;
	end;
	cam.FieldOfView = tonumber((getgenv()).fov) or 70;
	fovLockConn = (cam:GetPropertyChangedSignal("FieldOfView")):Connect(function()
		if (getgenv()).wide and cam.FieldOfView ~= (tonumber((getgenv()).fov) or 70) then
			cam.FieldOfView = tonumber((getgenv()).fov) or 70;
		end;
	end);
end;
local PLACE_NAME = ({
	[pOLD] = "Endless Doors [OLD]",
	[pEPIC] = "Endless Doors [OLD Epic Mode]",
	[pREN] = "Endless Doors",
	[pEMARC] = "Endless Doors [Epic Mode]",
	[pCLASS] = "Endless Doors [Retro #classic]"
})[game.PlaceId] or "unknown";
local SUBTITLE = "zavaled loves KitaFuzzi";
local TITLE = "Endless Doors";
local MODE_LABEL = PLACE_NAME:match("(%[[^%]]+%])") or PLACE_NAME;
local FOOTER = MODE_LABEL .. " | " .. SUBTITLE;
local function playerRoom()
	return tostring(LocalPlayer.leaderstats.Room.Value);
end;
local function playerBits()
	return tostring(LocalPlayer.leaderstats.Bits.Value);
end;
local function doubleBits()
	return tostring(LocalPlayer.Character.Values.DoubleBits.Value);
end;
local function fame()
	return tostring(LocalPlayer.Fame.Value);
end;
local function deaths()
	return tostring(LocalPlayer.Deaths.Value);
end;
local function rift()
	return tostring(LocalPlayer.Rift.Value);
end;
local function inGroup()
	return tostring(LocalPlayer.JoinedGroup.Value);
end;
local function curRoom()
	return tostring(Values.RoomsNumber.Value);
end;
local function phil()
	return tostring(Values.PhilMeter.Value);
end;
local function spider()
	return tostring(Values.SpiderChance.Value);
end;
local function revivePrice()
	return tostring(Values.RevivePrice.Value);
end;
local function alive()
	return tostring(Values.PlayersAlive.Value);
end;
local function inGame()
	return tostring(Values.PlayersInGame.Value);
end;
local function fuz()
	return charValStr("Collectibles", "Fuzzi");
end;
local function zav()
	return charValStr("Collectibles", "Zav");
end;
local function jake()
	return charValStr("Collectibles", "Jake");
end;
local function blue()
	return charValStr("Collectibles", "Blue");
end;
local function alan()
	return charValStr("Collectibles", "Alan");
end;
local function getBasePart(o)
	if o:IsA("BasePart") then
		return o;
	end;
	if o:IsA("Model") then
		if o.PrimaryPart then
			return o.PrimaryPart;
		end;
		return o:FindFirstChildWhichIsA("BasePart", true);
	end;
end;
local SAFE_TENDRILS_DIST = 30;
local tendrilsRoots = {};
local function addTendrils(m)
	if not (m and m:IsA("Model") and m.Name:lower() == "tendrils") then
		return;
	end;
	local root = m:FindFirstChild("Root") or m:FindFirstChildWhichIsA("BasePart", true);
	if root and root:IsA("BasePart") then
		tendrilsRoots[(#tendrilsRoots) + 1] = root;
	end;
end;
local function cleanTendrils(inst)
	for i = #tendrilsRoots, 1, -1 do
		local r = tendrilsRoots[i];
		if r == inst or (not (r and r.Parent and r:IsDescendantOf(Entities))) then
			table.remove(tendrilsRoots, i);
		end;
	end;
end;
for _, m in ipairs(Entities:GetChildren()) do
	addTendrils(m);
end;
trackConnection(Entities.ChildAdded:Connect(addTendrils));
trackConnection(Entities.DescendantRemoving:Connect(cleanTendrils));
nearestTendrilsDistance = function()
	local root = rootOf(LocalPlayer.Character);
	if not (root and root.Parent) then
		return math.huge, nil;
	end;
	local closest = math.huge;
	local closestRoot = nil;
	for i = #tendrilsRoots, 1, -1 do
		local r = tendrilsRoots[i];
		if not (r and r.Parent and r:IsDescendantOf(Entities)) then
			table.remove(tendrilsRoots, i);
		else
			local d = (root.Position - r.Position).Magnitude;
			if d < closest then
				closest = d;
				closestRoot = r;
			end;
		end;
	end;
	return closest, closestRoot;
end;
local healNames = {
	vitamins = true,
	bandage = true,
	["health tonic"] = true
};
local lastHealTick = 0;
local HEAL_COOLDOWN = 3;
local healing = false;
local function tryAutoHeal(h)
	if not (getgenv()).autoHeal then
		return;
	end;
	if not h or h.Health <= 0 then
		return;
	end;
	if healing then
		return;
	end;
	local max = h.MaxHealth > 0 and h.MaxHealth or 100;
	if h.Health > max * 0.5 then
		return;
	end;
	local now = tick();
	if now - lastHealTick < HEAL_COOLDOWN then
		return;
	end;
	local bp = LocalPlayer:FindFirstChildOfClass("Backpack");
	if not bp then
		return;
	end;
	for _, tool in ipairs(bp:GetChildren()) do
		if tool:IsA("Tool") then
			local n = tool.Name:lower();
			if healNames[n] then
				lastHealTick = now;
				healing = true;
				tool.Parent = LocalPlayer.Character;
				task.spawn(function()
					pcall(function()
						tool:Activate();
					end);
					task.wait(1.3);
					healing = false;
				end);
				break;
			end;
		end;
	end;
end;
local espItems = {};
local espConn;
local function ensureEspLoop()
	if espConn then
		return;
	end;
	espConn = RunService.RenderStepped:Connect(function()
		local root = rootOf(LocalPlayer.Character);
		for inst, data in pairs(espItems) do
			if not (inst and inst.Parent and data.base and data.base.Parent and data.box and data.box.Parent and data.label and data.label.Parent) then
				if data.box then
					data.box:Destroy();
				end;
				if data.billboard then
					data.billboard:Destroy();
				end;
				espItems[inst] = nil;
			elseif root then
				local d = (root.Position - data.base.Position).Magnitude;
				data.label.Text = string.format("%s | %.1f", data.text, d);
			end;
		end;
		if not next(espItems) then
			espConn:Disconnect();
			espConn = nil;
		end;
	end);
end;
local function CreateESP(target, color, label)
	local base = getBasePart(target);
	if not base then
		return;
	end;
	local existing = espItems[target];
	if existing then
		existing.text = label or target.Name;
		existing.base = base;
		return existing.box;
	end;
	local bc = color or Color3.new(1, 0, 0);
	local box = Instance.new("BoxHandleAdornment");
	box.Name = target.Name:lower() .. "_ESP";
	box.Adornee = base;
	box.Parent = target;
	box.AlwaysOnTop = true;
	box.ZIndex = 0;
	box.Transparency = 0.45;
	box.Color3 = bc;
	if target:IsA("Model") then
		local _, sz = target:GetBoundingBox();
		box.Size = sz + Vector3.new(0.1, 0.1, 0.1);
	else
		box.Size = base.Size + Vector3.new(0.1, 0.1, 0.1);
	end;
	local bb = Instance.new("BillboardGui");
	bb.Name = target.Name:lower() .. "_LABEL";
	bb.Parent = target;
	bb.Adornee = base;
	bb.Size = UDim2.new(0, 100, 0, 30);
	bb.StudsOffset = Vector3.new(0, box.Size.Y / 2 + 0.2, 0);
	bb.AlwaysOnTop = true;
	bb.ZIndexBehavior = Enum.ZIndexBehavior.Sibling;
	local tl = Instance.new("TextLabel");
	tl.Parent = bb;
	tl.Size = UDim2.new(1, 0, 1, 0);
	tl.BackgroundTransparency = 1;
	tl.Font = Enum.Font.SourceSansBold;
	tl.Text = label or target.Name;
	tl.TextSize = 14;
	tl.TextColor3 = Color3.new(1, 1, 1);
	tl.TextStrokeTransparency = 0.5;
	espItems[target] = {
		base = base,
		box = box,
		billboard = bb,
		label = tl,
		text = label or target.Name
	};
	ensureEspLoop();
	return box;
end;
local function RemoveESP(p)
	if espItems[p] then
		local data = espItems[p];
		if data.box then
			data.box:Destroy();
		end;
		if data.billboard then
			data.billboard:Destroy();
		end;
		espItems[p] = nil;
	end;
	pcall(function()
		for _, c in ipairs(p:GetChildren()) do
			if espItems[c] then
				local data = espItems[c];
				if data.box then
					data.box:Destroy();
				end;
				if data.billboard then
					data.billboard:Destroy();
				end;
				espItems[c] = nil;
			end;
			if c:IsA("BoxHandleAdornment") or c:IsA("BillboardGui") or c:IsA("Highlight") then
				c:Destroy();
			end;
		end;
	end);
end;
trackConnection(PPromptService.PromptButtonHoldBegan:Connect(function(p)
	task.defer(function()
		fireproximityprompt(p);
	end);
end));
local junk = {
	fdmg = true,
	brokenlamp = true,
	longcrate = true,
	crate = true,
	chair = true,
	sofa = true,
	fire = true
};
task.spawn(function()
	repeat
		task.wait();
	until LocalPlayer.Character;
	task.wait(2);
	for _, d in ipairs(game:GetDescendants()) do
		if junk[d.Name:lower()] then
			task.defer(function()
				if d and d.Parent then
					d:Destroy();
				end;
			end);
		end;
	end;
end);
task.spawn(function()
	if game.PlaceId == pREN then
		while task.wait() do
			disableRagdoll();
		end;
	end;
end);
trackConnection(workspace.DescendantAdded:Connect(function(o)
	if junk[o.Name:lower()] then
		task.defer(function()
			if o and o.Parent then
				o:Destroy();
			end;
		end);
	end;
end));
task.spawn(function()
	local function setAutoJump(h)
		if h then
			h.AutoJumpEnabled = false;
		end;
	end;
	setAutoJump(LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"));
	trackConnection(LocalPlayer.CharacterAdded:Connect(function(ch)
		setAutoJump(ch:WaitForChild("Humanoid", 5));
	end));
end);
local function resolveHolder(inst)
	if not inst then
		return nil;
	end;
	local p = inst.Parent;
	if p and (p:IsA("Model") or p:IsA("BasePart")) then
		return p;
	end;
	local mdl = inst:FindFirstAncestorOfClass("Model");
	if mdl then
		return mdl;
	end;
	local bp = inst:FindFirstAncestorOfClass("BasePart");
	if bp then
		return bp;
	end;
	return p;
end;
local function resolveDistancePart(inst)
	local h = resolveHolder(inst);
	if not h then
		return nil;
	end;
	if h:IsA("Model") then
		if h.PrimaryPart then
			return h.PrimaryPart;
		end;
		return h:FindFirstChildWhichIsA("BasePart", true);
	end;
	return h;
end;
local function holderName(inst)
	local h = resolveHolder(inst);
	return h and h.Name or "unknown";
end;
local proximityPrompts = {};
local function onPPAdded(o)
	proximityPrompts[(#proximityPrompts) + 1] = o;
end;
local function onPPRemoved(o)
	for i, v in ipairs(proximityPrompts) do
		if v == o then
			table.remove(proximityPrompts, i);
			break;
		end;
	end;
end;
for _, o in ipairs(workspace:GetDescendants()) do
	if o:IsA("ProximityPrompt") then
		onPPAdded(o);
	end;
end;
trackConnection(workspace.DescendantAdded:Connect(function(o)
	if o:IsA("ProximityPrompt") then
		onPPAdded(o);
	end;
end));
trackConnection(workspace.DescendantRemoving:Connect(function(o)
	if o:IsA("ProximityPrompt") then
		onPPRemoved(o);
	end;
end));
local lastHandle = 0;
local selectedPromptNames = {};
local selectedPromptDisplay = {};
local dropdownObj;
local modeLabel;
local suppressDropdownCallback = false;
local function addSelectionName(name)
	if typeof(name) ~= "string" then
		return;
	end;
	local trimmed = (name:gsub("^%s+", "")):gsub("%s+$", "");
	if trimmed == "" or trimmed == "None" then
		return;
	end;
	local key = trimmed:lower();
	selectedPromptNames[key] = true;
	selectedPromptDisplay[key] = trimmed;
end;
local function clearSelection()
	for k in pairs(selectedPromptNames) do
		selectedPromptNames[k] = nil;
	end;
	for k in pairs(selectedPromptDisplay) do
		selectedPromptDisplay[k] = nil;
	end;
end;
local function selectionEmpty()
	return next(selectedPromptNames) == nil;
end;
local function currentSelectionList()
	local list = {};
	for _, display in pairs(selectedPromptDisplay) do
		list[(#list) + 1] = display;
	end;
	table.sort(list);
	return list;
end;
local function selectionDictionary()
	local dict = {};
	for _, display in pairs(selectedPromptDisplay) do
		dict[display] = true;
	end;
	return dict;
end;
local function updateModeLabelText()
	if not modeLabel then
		return;
	end;
	if selectionEmpty() then
		modeLabel:Set("Mode: Default (all prompts)");
	else
		local names = currentSelectionList();
		modeLabel:Set("Mode: Selected holders only (" .. table.concat(names, ", ") .. ")");
	end;
end;
local function applySelectionFromValue(value)
	clearSelection();
	if typeof(value) == "table" then
		if value[1] ~= nil then
			for _, entry in ipairs(value) do
				addSelectionName(entry);
			end;
		else
			for entry, state in pairs(value) do
				if state then
					addSelectionName(entry);
				end;
			end;
		end;
	elseif typeof(value) == "string" then
		addSelectionName(value);
	end;
	updateModeLabelText();
end;
local function promptAllowed(pp)
	if not (pp and pp.Parent) then
		return false;
	end;
	if selectionEmpty() then
		return pp:IsA("ProximityPrompt") and pp.Name == "ProximityPrompt";
	else
		if not pp:IsA("ProximityPrompt") then
			return false;
		end;
		local n = holderName(pp);
		return n and selectedPromptNames[n:lower()] or false;
	end;
end;
local function firePrompts()
	local root = rootOf(LocalPlayer.Character);
	if not (root and root.Parent) then
		return;
	end;
	local bitsStat = LocalPlayer.leaderstats and LocalPlayer.leaderstats:FindFirstChild("Bits");
	for i = #proximityPrompts, 1, -1 do
		local pp = proximityPrompts[i];
		if not (pp and pp.Parent) then
			table.remove(proximityPrompts, i);
		elseif promptAllowed(pp) then
			local hold = resolveHolder(pp);
			local bp = resolveDistancePart(pp);
			if bp then
				local d = (root.Position - bp.Position).Magnitude;
				local rad = pp.MaxActivationDistance or 12;
				if d <= rad + 6 then
					local nm = hold and hold.Name:lower() or "";
					local skip = false;
					if hold then
						for _, c in ipairs(hold:GetChildren()) do
							if c:IsA("BoolValue") and (c.Name:lower()):find("greed") and c.Value then
								skip = true;
								break;
							end;
						end;
					end;
					if not skip and (not (nm == "handle" and greedActive)) then
						if game.PlaceId == pEPIC or game.PlaceId == pEMARC then
							local b = bitsStat and bitsStat.Value or 0;
							if b >= 2500 and nm ~= "bit" or b < 2500 then
								fireproximityprompt(pp);
							end;
						elseif game.PlaceId == pCLASS then
							if nm == "handle" then
								local now = tick();
								if now - lastHandle >= 0.4 then
									fireproximityprompt(pp);
									lastHandle = now;
								end;
							else
								fireproximityprompt(pp);
							end;
						else
							fireproximityprompt(pp);
						end;
					end;
				end;
			end;
		end;
	end;
end;
local ObsidianRepo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/";
local ObsidianLibrary = (loadstring(game:HttpGet(ObsidianRepo .. "Library.lua")))();
local ObsidianSaveManager = (loadstring(game:HttpGet(ObsidianRepo .. "addons/SaveManager.lua")))();
local ObsidianThemeManager = (loadstring(game:HttpGet(ObsidianRepo .. "addons/ThemeManager.lua")))();
local function sanitizeIdSegment(text)
	local str = typeof(text) == "string" and text or tostring((text or ""));
	str = str:gsub("%W", "");
	if str == "" then
		str = "ctrl";
	end;
	return str;
end;
local function copyArray(list)
	local new = {};
	if typeof(list) == "table" then
		for i, v in ipairs(list) do
			new[i] = v;
		end;
	end;
	return new;
end;
local function snapshotSelection(dict)
	local values = {};
	if typeof(dict) == "table" then
		for key, enabled in pairs(dict) do
			if enabled then
				values[(#values) + 1] = key;
			end;
		end;
	end;
	table.sort(values, function(a, b)
		return tostring(a) < tostring(b);
	end);
	return values;
end;
local function toDictionary(list)
	local dict = {};
	if typeof(list) == "table" then
		for _, value in ipairs(list) do
			if typeof(value) == "string" then
				dict[value] = true;
			end;
		end;
	end;
	return dict;
end;
local function inferRounding(step)
	if typeof(step) ~= "number" or step <= 0 then
		return 0;
	end;
	local decimals = (tostring(step)):match("%.(%d+)");
	return decimals and (#decimals) or 0;
end;
local function normalizeSoundId(value)
	if value == nil then
		return nil;
	end;
	local valueType = typeof(value);
	if valueType == "number" then
		if value <= 0 then
			return nil;
		end;
		return string.format("rbxassetid://%d", value);
	elseif valueType == "string" then
		local trimmed = value:match("^%s*(.-)%s*$");
		if trimmed == "" then
			return nil;
		end;
		if trimmed:match("^%d+$") then
			return "rbxassetid://" .. trimmed;
		end;
		return trimmed;
	end;
	return nil;
end;
local ObsidianUI = {
	Library = ObsidianLibrary,
	SaveManager = ObsidianSaveManager,
	ThemeManager = ObsidianThemeManager,
	_configEnabled = false,
	_configName = nil,
	_isLoadingConfig = false,
	NotifySoundId = "rbxassetid://8551372796",
	NotifySoundVolume = 2,
	NotifySoundEnabled = true
};
local function disconnectConn(conn)
	if conn then
		pcall(function()
			conn:Disconnect();
		end);
	end;
end;
function ObsidianUI:Cleanup()
	if self._cleaned then
		return;
	end;
	self._cleaned = true;
	scriptRunning = false;
	local tracked = {
		brightLoop,
		antiAFKConn,
		fovLockConn,
		cameraConn,
		infJumpConn,
		mobHoldConn,
		mobDownConn,
		mobUpConn,
		overCon,
		lurkCon,
		watchCon,
		flowCon,
		abyssCon,
		takerCon,
		chaseCon
	};
	for _, conn in ipairs(tracked) do
		disconnectConn(conn);
	end;
	brightLoop = nil;
	antiAFKConn = nil;
	fovLockConn = nil;
	cameraConn = nil;
	infJumpConn = nil;
	mobHoldConn = nil;
	mobDownConn = nil;
	mobUpConn = nil;
	overCon = nil;
	lurkCon = nil;
	watchCon = nil;
	flowCon = nil;
	abyssCon = nil;
	takerCon = nil;
	chaseCon = nil;
	for _, conn in ipairs(activeConnections) do
		disconnectConn(conn);
	end;
	activeConnections = {};
	(getgenv()).chaos = false;
	(getgenv()).entityEsp = false;
	(getgenv()).keyESP = false;
	(getgenv()).bitESP = false;
	(getgenv()).leverESP = false;
	(getgenv()).batteryESP = false;
	(getgenv()).remoteThingy = false;
	(getgenv()).entityNotif = false;
	(getgenv()).sped = false;
	(getgenv()).jumpy = false;
	(getgenv()).teletodoor = false;
	(getgenv()).teletokey = false;
	(getgenv()).teletolever = false;
	pcall(function()
		for _, obj in ipairs(Entities:GetDescendants()) do
			RemoveESP(obj);
		end;
		for _, obj in ipairs(Rooms:GetDescendants()) do
			RemoveESP(obj);
		end;
	end);
end;
local WindowMeta = {};
WindowMeta.__index = WindowMeta;
local TabMeta = {};
TabMeta.__index = TabMeta;
local LabelMeta = {};
LabelMeta.__index = LabelMeta;
local DropdownMeta = {};
DropdownMeta.__index = DropdownMeta;
function ObsidianUI:_setupConfig(config)
	if self.SaveManager and config and config.Enabled then
		self.SaveManager:SetLibrary(self.Library);
		self.SaveManager:IgnoreThemeSettings();
		self.SaveManager:SetFolder(config.FolderName or "ObsidianConfigs");
		self.SaveManager:SetSubFolder(config.SubFolder or "");
		self._configEnabled = true;
		self._configName = config.FileName or "default";
	else
		self._configEnabled = false;
		self._configName = nil;
	end;
	if self.ThemeManager then
		self.ThemeManager:SetLibrary(self.Library);
		self.ThemeManager:SetFolder(config and config.FolderName or "ObsidianConfigs");
	end;
end;
function ObsidianUI:_autoSave()
	if not (self._configEnabled and self._configName and self.SaveManager) or self._isLoadingConfig then
		return;
	end;
	local ok, err = self.SaveManager:Save(self._configName);
	if not ok and err then
		warn("[ObsidianCompat] Failed to save config:", err);
	end;
end;
function ObsidianUI:LoadConfiguration()
	if not (self._configEnabled and self._configName and self.SaveManager) then
		return;
	end;
	self._isLoadingConfig = true;
	local ok = self.SaveManager:Load(self._configName);
	self._isLoadingConfig = false;
	if not ok then
		self.SaveManager:Save(self._configName);
	end;
end;
function ObsidianUI:_playNotifySound(soundId, volume)
	if self.NotifySoundEnabled == false then
		return;
	end;
	local normalized = normalizeSoundId(soundId);
	if not normalized then
		return;
	end;
	local vol = math.clamp(tonumber(volume) or self.NotifySoundVolume or 1, 0, 10);
	local soundInstance = Instance.new("Sound");
	soundInstance.SoundId = normalized;
	soundInstance.Volume = vol;
	soundInstance.PlayOnRemove = true;
	soundInstance.Parent = SoundService;
	soundInstance:Destroy();
end;
function ObsidianUI:Notify(payload, duration)
	local message = payload;
	local soundId = self.NotifySoundId;
	local soundVolume = self.NotifySoundVolume;
	if typeof(payload) == "table" then
		local data = {};
		for k, v in pairs(payload) do
			if k ~= "SoundId" and k ~= "SoundVolume" and k ~= "Header" and k ~= "Content" and k ~= "Duration" then
				data[k] = v;
			end;
		end;
		data.Title = payload.Title or payload.Header or data.Title or "Notification";
		data.Description = payload.Description or payload.Content or data.Description or "";
		data.Time = payload.Time or payload.Duration or data.Time;
		message = data;
		soundId = payload.SoundId or soundId;
		soundVolume = payload.SoundVolume or soundVolume;
	end;
	local result = self.Library:Notify(message, duration);
	if soundId then
		self:_playNotifySound(soundId, soundVolume);
	end;
	return result;
end;
function ObsidianUI:CreateWindow(options)
	options = options or {};
	local window = self.Library:CreateWindow({
		Title = options.Name or options.LoadingTitle or "Obsidian",
		Footer = options.Footer or options.LoadingSubtitle or "",
		NotifySide = options.NotifySide or "Left",
		ShowCustomCursor = true
	});
	self:_setupConfig(options.ConfigurationSaving);
	local wrapper = setmetatable({
		_window = window,
		_ObsidianUI = self,
		_idCounters = {}
	}, WindowMeta);
	return wrapper;
end;
function WindowMeta:_nextId(prefix, tabName)
	tabName = sanitizeIdSegment(tabName or "tab");
	self._idCounters[prefix] = (self._idCounters[prefix] or 0) + 1;
	return string.format("%s_%s_%d", prefix, tabName, self._idCounters[prefix]);
end;
function WindowMeta:_autoSave()
	if self._ObsidianUI then
		self._ObsidianUI:_autoSave();
	end;
end;
function WindowMeta:AddTab(name, icon, description)
	local tab = self._window:AddTab(name, icon, description);
	local wrapper = setmetatable({
		_windowWrapper = self,
		_tab = tab,
		_group = nil,
		_tabName = name
	}, TabMeta);
	return wrapper;
end;
function TabMeta:_groupbox()
	if not self._group then
		self._group = self._tab:AddLeftGroupbox((self._tabName or "Tab") .. " Controls", "list");
	end;
	return self._group;
end;
function TabMeta:_autoSave()
	self._windowWrapper:_autoSave();
end;
function TabMeta:_nextId(kind)
	return self._windowWrapper:_nextId(kind, self._tabName);
end;
function TabMeta:AddGroupbox(title, icon, side)
	local tab = self._tab;
	if not tab then
		return self;
	end;
	local group;
	if side == "right" then
		group = tab:AddRightGroupbox(title or (self._tabName or "Tab") .. " Right", icon or "layout-panel-right");
	else
		group = tab:AddLeftGroupbox(title or (self._tabName or "Tab") .. " Left", icon or "layout-panel-left");
	end;
	return setmetatable({
		_windowWrapper = self._windowWrapper,
		_tab = tab,
		_group = group,
		_tabName = self._tabName
	}, TabMeta);
end;
function TabMeta:AddSection(text)
	local group = self:_groupbox();
	group:AddDivider();
	if text and text ~= "" then
		group:AddLabel(text, true);
	end;
end;
function TabMeta:AddLabel(text)
	local label = (self:_groupbox()):AddLabel(text or "", true);
	return setmetatable({
		_label = label
	}, LabelMeta);
end;
function LabelMeta:Set(value)
	if self._label and self._label.SetText then
		self._label:SetText(value or "");
	end;
end;
function TabMeta:AddButton(info)
	info = info or {};
	return (self:_groupbox()):AddButton({
		Text = info.Name or "Button",
		Func = function()
			if info.Callback then
				info.Callback();
			end;
		end
	});
end;
function TabMeta:AddToggle(info)
	info = info or {};
	local id = info.Flag or self:_nextId("toggle");
	return (self:_groupbox()):AddToggle(id, {
		Text = info.Name or id,
		Default = info.CurrentValue or false,
		Callback = function(state)
			if info.Callback then
				info.Callback(state);
			end;
			self:_autoSave();
		end
	});
end;
function TabMeta:AddSlider(info)
	info = info or {};
	local id = info.Flag or self:_nextId("slider");
	local range = info.Range or {
		0,
		100
	};
	local min = tonumber(range[1]) or 0;
	local max = tonumber(range[2]) or min + 100;
	return (self:_groupbox()):AddSlider(id, {
		Text = info.Name or id,
		Default = info.CurrentValue or min,
		Min = min,
		Max = max,
		Rounding = inferRounding(info.Increment),
		Callback = function(value)
			if info.Callback then
				info.Callback(value);
			end;
			self:_autoSave();
		end
	});
end;
function TabMeta:AddInput(info)
	info = info or {};
	local id = info.Flag or self:_nextId("input");
	return (self:_groupbox()):AddInput(id, {
		Text = info.Name or id,
		Default = info.CurrentValue or "",
		Placeholder = info.PlaceholderText,
		ClearTextOnFocus = info.RemoveTextAfterFocusLost or false,
		Callback = function(value)
			if info.Callback then
				info.Callback(value);
			end;
			self:_autoSave();
		end
	});
end;
function TabMeta:AddDropdown(info)
	info = info or {};
	local id = info.Flag or self:_nextId("dropdown");
	local values = copyArray(info.Options or {});
	local multi = info.MultiSelection or info.MultipleOptions or false;
	local default = info.CurrentOption;
	if multi then
		if typeof(default) == "table" and next(default) then
			local arr = {};
			for _, v in ipairs(default) do
				arr[(#arr) + 1] = v;
			end;
			default = arr;
		elseif typeof(default) == "string" then
			default = {
				default
			};
		else
			default = nil;
		end;
	elseif typeof(default) == "table" then
		default = default[1];
	end;
	local dropdown;
	local function emitSelection()
		local current;
		if dropdown then
			if dropdown.Multi then
				current = snapshotSelection(dropdown.Value or {});
			else
				current = dropdown.Value;
			end;
		end;
		if info.Callback then
			info.Callback(current);
		end;
		self:_autoSave();
	end;
	dropdown = (self:_groupbox()):AddDropdown(id, {
		Text = info.Name or id,
		Values = values,
		Default = default,
		Multi = multi,
		Callback = function()
			task.defer(emitSelection);
		end
	});
	return setmetatable({
		_dropdown = dropdown
	}, DropdownMeta);
end;
function DropdownMeta:Refresh(values, keepCurrent)
	if not self._dropdown then
		return;
	end;
	local dropdown = self._dropdown;
	local previous;
	if keepCurrent then
		if dropdown.Multi then
			previous = snapshotSelection(dropdown.Value);
		else
			previous = dropdown.Value;
		end;
	end;
	dropdown:SetValues(copyArray(values or {}));
	if keepCurrent and previous then
		if dropdown.Multi then
			dropdown:SetValue(toDictionary(previous));
		elseif table.find(values or {}, previous) then
			dropdown:SetValue(previous);
		end;
	end;
end;
function DropdownMeta:SetValue(value)
	if not self._dropdown then
		return;
	end;
	self._dropdown:SetValue(value);
end;
local Win = ObsidianUI:CreateWindow({
	Name = TITLE,
	LoadingTitle = TITLE,
	LoadingSubtitle = SUBTITLE,
	Footer = FOOTER,
	ConfigurationSaving = {
		Enabled = true,
		FolderName = "Endless Doors",
		FileName = "RENOVATION"
	}
});
if ObsidianUI.Library and ObsidianUI.Library.OnUnload then
	ObsidianUI.Library:OnUnload(function()
		ObsidianUI:Cleanup();
	end);
end;
local tabMain = Win:AddTab("Main", "layout-dashboard", "Primary actions");
local coreGroup = tabMain:AddGroupbox("Core Actions", "zap", "left");
coreGroup:AddButton({
	Name = "Infinite Flashlight",
	Callback = function()
		task.defer(function()
			(S("ReplicatedStorage")).Remotes.FLASHLIGHT_TOGGLE:FireServer(false, 100000000000000);
		end);
	end
});
coreGroup:AddButton({
	Name = "God Mode [WIP]",
	Callback = function()
		task.defer(function()
			(loadstring(game:HttpGet("https://raw.githubusercontent.com/ltseverydayyou/endless-doors/main/ED%20god")))();
		end);
	end
});
coreGroup:AddToggle({
	Name = "Disable Look Script",
	CurrentValue = false,
	Flag = "lookerLook",
	Callback = function(v)
		task.defer(function()
			if game.PlaceId ~= pCLASS then
				(LocalPlayer.PlayerScripts:FindFirstChild("Looking")).Enabled = not v;
			end;
		end);
	end
});
coreGroup:AddToggle({
	Name = "Disable Camera Shaking",
	CurrentValue = false,
	Flag = "camShaking",
	Callback = function(v)
		task.defer(function()
			if game.PlaceId == pREN then
				(LocalPlayer.PlayerScripts:FindFirstChild("LocalShaking")).Enabled = not v;
				(LocalPlayer.PlayerScripts:FindFirstChild("CameraShake")).Enabled = not v;
			end;
		end);
	end
});
coreGroup:AddToggle({
	Name = "Full Bright",
	CurrentValue = false,
	Flag = "brightLol",
	Callback = function(v)
		task.defer(function()
			local L = S("Lighting");
			if v then
				if brightLoop then
					brightLoop:Disconnect();
				end;
				brightLoop = RunService.Stepped:Connect(function()
					L.ClockTime = 0;
					L.FogEnd = 10000000000;
					L.FogStart = 0;
					L.GlobalShadows = false;
					L.OutdoorAmbient = Color3.fromRGB(128, 128, 128);
					L.Brightness = 3;
				end);
			else
				if brightLoop then
					brightLoop:Disconnect();
					brightLoop = nil;
				end;
				L.ClockTime = 0;
				L.FogEnd = 100000;
				L.FogStart = 0;
				L.GlobalShadows = false;
				L.OutdoorAmbient = Color3.fromRGB(128, 128, 128);
				L.Brightness = 1;
			end;
		end);
	end
});
coreGroup:AddToggle({
	Name = "Anti AFK",
	CurrentValue = false,
	Flag = "antiAFK",
	Callback = function(v)
		task.defer(function()
			if v then
				if antiAFKConn then
					antiAFKConn:Disconnect();
				end;
				antiAFKConn = LocalPlayer.Idled:Connect(function()
					(S("VirtualUser")):Button2Down(Vector2.new(), workspace.CurrentCamera.CFrame);
					task.wait(1);
					(S("VirtualUser")):Button2Up(Vector2.new(), workspace.CurrentCamera.CFrame);
				end);
			elseif antiAFKConn then
				antiAFKConn:Disconnect();
				antiAFKConn = nil;
			end;
		end);
	end
});
coreGroup:AddButton({
	Name = "Play Again",
	Callback = function()
		task.defer(function()
			(S("ReplicatedStorage")).Remotes.PLAY_AGAIN:FireServer();
		end);
	end
});
coreGroup:AddButton({
	Name = "Buy Respawn",
	Callback = function()
		task.defer(function()
			(S("ReplicatedStorage")).Remotes.BUY_RESPAWN:FireServer();
		end);
	end
});
coreGroup:AddButton({
	Name = "Die",
	Callback = function()
		task.defer(function()
			(S("ReplicatedStorage")).Remotes.F_DMG:FireServer(1000);
		end);
	end
});
local interactGroup = tabMain:AddGroupbox("Interactables", "list", "left");
local promptList = {
	"None"
};
local function rebuildPromptList()
	local seen = {};
	for _, pp in ipairs(proximityPrompts) do
		if pp and pp.Parent then
			local n = holderName(pp);
			if n and n ~= "" then
				seen[n] = true;
			end;
		end;
	end;
	local new = {
		"None"
	};
	for k in pairs(seen) do
		new[(#new) + 1] = k;
	end;
	table.sort(new, function(a, b)
		return a < b;
	end);
	local changed = false;
	if #new ~= (#promptList) then
		changed = true;
	else
		for i = 1, #new do
			if new[i] ~= promptList[i] then
				changed = true;
				break;
			end;
		end;
	end;
	if changed then
		promptList = new;
		if dropdownObj then
			suppressDropdownCallback = true;
			local ok, err = pcall(function()
				dropdownObj:Refresh(promptList, true);
				dropdownObj:SetValue(selectionDictionary());
			end);
			suppressDropdownCallback = false;
			if not ok then
				warn("[Interactables] Failed to refresh prompt list:", err);
			end;
		end;
	end;
end;
local lastPromptTick = 0;
dropdownObj = interactGroup:AddDropdown({
	Name = "Prompt Names [BUGGY/WIP]",
	Options = promptList,
	CurrentOption = {},
	MultiSelection = true,
	MultipleOptions = true,
	Flag = "PromptNamesMulti",
	Callback = function(opt)
		if suppressDropdownCallback then
			return;
		end;
		applySelectionFromValue(opt);
	end
});
interactGroup:AddButton({
	Name = "Clear Selection",
	Callback = function()
		suppressDropdownCallback = true;
		clearSelection();
		updateModeLabelText();
		if dropdownObj then
			local ok, err = pcall(function()
				dropdownObj:SetValue({});
			end);
			if not ok then
				warn("[Interactables] Failed to clear prompt selection:", err);
			end;
		end;
		suppressDropdownCallback = false;
	end
});
interactGroup:AddToggle({
	Name = "Auto Interact",
	CurrentValue = false,
	Flag = "AuraAll",
	Callback = function(v)
		(getgenv()).chaos = v;
	end
});
interactGroup:AddSlider({
	Name = "Prompt Fire Interval (s)",
	Range = {
		0,
		1
	},
	Increment = 0.05,
	CurrentValue = tonumber((getgenv()).promptDelay) or 0,
	Flag = "PromptDelay",
	Callback = function(value)
		(getgenv()).promptDelay = value;
	end
});
interactGroup:AddSection("Info");
modeLabel = interactGroup:AddLabel("Mode: Default (all prompts)");
updateModeLabelText();
interactGroup:AddLabel("Select one or more holder names to target only those prompts.");
interactGroup:AddLabel("The list updates automatically.");
task.spawn(function()
	while task.wait(0.35) do
		pcall(rebuildPromptList);
	end;
end);
trackConnection(workspace.DescendantAdded:Connect(function(o)
	if o:IsA("ProximityPrompt") then
		task.defer(rebuildPromptList);
	end;
end));
trackConnection(workspace.DescendantRemoving:Connect(function(o)
	if o:IsA("ProximityPrompt") then
		task.defer(rebuildPromptList);
	end;
end));
local espGroup = tabMain:AddGroupbox("ESP & Tracking", "eye", "left");
espGroup:AddToggle({
	Name = "Entity Esp",
	CurrentValue = false,
	Flag = "entityESP",
	Callback = function(v)
		task.defer(function()
			(getgenv()).entityEsp = v;
			if not v then
				for _, e in ipairs(Entities:GetDescendants()) do
					RemoveESP(e);
				end;
			else
				for _, e in ipairs(Entities:GetChildren()) do
					CreateESP(e);
				end;
			end;
		end);
	end
});
espGroup:AddToggle({
	Name = "Key Esp",
	CurrentValue = false,
	Flag = "KeyESP",
	Callback = function(v)
		task.defer(function()
			(getgenv()).keyESP = v;
			if not v then
				for _, p in ipairs(Rooms:GetDescendants()) do
					if p:IsA("BasePart") and p.Name:lower() == "roomkey" and p.Parent.Name:lower() ~= "door" then
						RemoveESP(p);
					end;
				end;
			else
				for _, p in ipairs(Rooms:GetDescendants()) do
					if p:IsA("BasePart") and p.Name:lower() == "roomkey" and p.Parent.Name:lower() ~= "door" then
						CreateESP(p, Color3.new(1, 1, 0), "Key");
					end;
				end;
			end;
		end);
	end
});
espGroup:AddToggle({
	Name = "Bits Esp",
	CurrentValue = false,
	Flag = "BitsESP",
	Callback = function(v)
		task.defer(function()
			(getgenv()).bitESP = v;
			if not v then
				for _, p in ipairs(Rooms:GetDescendants()) do
					if p:IsA("BasePart") and p.Name:lower() == "bit" then
						RemoveESP(p);
					end;
				end;
			else
				for _, p in ipairs(Rooms:GetDescendants()) do
					if p:IsA("BasePart") and p.Name:lower() == "bit" then
						CreateESP(p, Color3.new(1, 0.666667, 0));
					end;
				end;
			end;
		end);
	end
});
espGroup:AddToggle({
	Name = "Lever Esp",
	CurrentValue = false,
	Flag = "LeverESP",
	Callback = function(v)
		task.defer(function()
			(getgenv()).leverESP = v;
			if not v then
				for _, p in ipairs(Rooms:GetDescendants()) do
					if p:IsA("BasePart") and p.Name:lower() == "lever" then
						RemoveESP(p);
					end;
				end;
			else
				for _, p in ipairs(Rooms:GetDescendants()) do
					if p:IsA("BasePart") and p.Name:lower() == "lever" then
						CreateESP(p, Color3.fromRGB(139, 145, 165));
					end;
				end;
			end;
		end);
	end
});
espGroup:AddToggle({
	Name = "Battery Esp",
	CurrentValue = false,
	Flag = "BatteryESP",
	Callback = function(v)
		task.defer(function()
			(getgenv()).batteryESP = v;
			if not v then
				for _, p in ipairs(Rooms:GetDescendants()) do
					if p:IsA("BasePart") and p.Name:lower() == "battery" then
						RemoveESP(p);
					end;
				end;
			else
				for _, p in ipairs(Rooms:GetDescendants()) do
					if p:IsA("BasePart") and p.Name:lower() == "battery" then
						CreateESP(p, Color3.new(0, 0.666667, 0));
					end;
				end;
			end;
		end);
	end
});
espGroup:AddToggle({
	Name = "Entity Remote Logger",
	CurrentValue = false,
	Flag = "entRem",
	Callback = function(v)
		(getgenv()).remoteThingy = v;
	end
});
espGroup:AddToggle({
	Name = "Entity Notifier",
	CurrentValue = false,
	Flag = "entityNotifs",
	Callback = function(v)
		(getgenv()).entityNotif = v;
	end
});
local bypassGroup = tabMain:AddGroupbox("Bypasses", "shield", "right");
bypassGroup:AddSection("General");
bypassGroup:AddToggle({
	Name = "Bypass Overseer",
	CurrentValue = false,
	Flag = "overSeer",
	Callback = function(v)
		task.defer(function()
			if v then
				if overCon then
					overCon:Disconnect();
				end;
				overCon = Entities.ChildAdded:Connect(function(ent)
					if ent.Name:lower() == "overseer" then
						task.defer(function()
							if ent and ent.Parent then
								ent:Destroy();
							end;
						end);
					end;
				end);
				for _, ent in ipairs(Entities:GetChildren()) do
					if ent.Name:lower() == "overseer" then
						task.defer(function()
							if ent and ent.Parent then
								ent:Destroy();
							end;
						end);
					end;
				end;
			elseif overCon then
				overCon:Disconnect();
				overCon = nil;
			end;
		end);
	end
});
bypassGroup:AddToggle({
	Name = "Bypass Lurker",
	CurrentValue = false,
	Flag = "lurkER",
	Callback = function(v)
		task.defer(function()
			if v then
				if lurkCon then
					lurkCon:Disconnect();
				end;
				lurkCon = workspace.DescendantAdded:Connect(function(o)
					if o.Name:lower() == "lurker" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end);
				for _, o in ipairs(workspace:GetDescendants()) do
					if o.Name:lower() == "lurker" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end;
			elseif lurkCon then
				lurkCon:Disconnect();
				lurkCon = nil;
			end;
		end);
	end
});
bypassGroup:AddToggle({
	Name = "Bypass Watchbane",
	CurrentValue = false,
	Flag = "watcherBANE",
	Callback = function(v)
		task.defer(function()
			if v then
				if watchCon then
					watchCon:Disconnect();
				end;
				watchCon = workspace.DescendantAdded:Connect(function(o)
					if o.Name:lower() == "watchbane" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end);
				for _, o in ipairs(workspace:GetDescendants()) do
					if o.Name:lower() == "watchbane" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end;
			elseif watchCon then
				watchCon:Disconnect();
				watchCon = nil;
			end;
		end);
	end
});
bypassGroup:AddToggle({
	Name = "Bypass FlowerGrowth",
	CurrentValue = false,
	Flag = "flowerGrowth",
	Callback = function(v)
		task.defer(function()
			if v then
				if flowCon then
					flowCon:Disconnect();
				end;
				flowCon = workspace.DescendantAdded:Connect(function(o)
					if o.Name:lower() == "flowergrowth" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end);
				for _, o in ipairs(workspace:GetDescendants()) do
					if o.Name:lower() == "flowergrowth" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end;
			elseif flowCon then
				flowCon:Disconnect();
				flowCon = nil;
			end;
		end);
	end
});
bypassGroup:AddToggle({
	Name = "Bypass Abyss",
	CurrentValue = false,
	Flag = "abyssKILL",
	Callback = function(v)
		task.defer(function()
			if v then
				if abyssCon then
					abyssCon:Disconnect();
				end;
				abyssCon = workspace.DescendantAdded:Connect(function(o)
					if o.Name:lower() == "abysskill" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end);
				for _, o in ipairs(workspace:GetDescendants()) do
					if o.Name:lower() == "abysskill" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end;
			elseif abyssCon then
				abyssCon:Disconnect();
				abyssCon = nil;
			end;
		end);
	end
});
bypassGroup:AddSection("Bypass [Special]");
bypassGroup:AddToggle({
	Name = "Bypass Taker [HEIST MODIFIER]",
	CurrentValue = false,
	Flag = "TAKERRRRR",
	Callback = function(v)
		task.defer(function()
			if v then
				if takerCon then
					takerCon:Disconnect();
				end;
				takerCon = workspace.DescendantAdded:Connect(function(o)
					if o.Name:lower() == "taker" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end);
				for _, o in ipairs(workspace:GetDescendants()) do
					if o.Name:lower() == "taker" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end;
			elseif takerCon then
				takerCon:Disconnect();
				takerCon = nil;
			end;
		end);
	end
});
bypassGroup:AddToggle({
	Name = "Bypass ChaseTrigger [EPIC MODE]",
	CurrentValue = false,
	Flag = "chaseTrigger",
	Callback = function(v)
		task.defer(function()
			if v then
				if chaseCon then
					chaseCon:Disconnect();
				end;
				chaseCon = workspace.DescendantAdded:Connect(function(o)
					if o.Name:lower() == "chasetrigger" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end);
				for _, o in ipairs(workspace:GetDescendants()) do
					if o.Name:lower() == "chasetrigger" then
						task.defer(function()
							if o and o.Parent then
								o:Destroy();
							end;
						end);
					end;
				end;
			elseif chaseCon then
				chaseCon:Disconnect();
				chaseCon = nil;
			end;
		end);
	end
});
local playerGroup = tabMain:AddGroupbox("Player Tweaks", "user", "right");
playerGroup:AddSlider({
	Name = "Set WalkSpeed",
	Range = game.PlaceId == pCLASS and {
		0,
		35
	} or {
		0,
		100
	},
	Increment = 1,
	CurrentValue = 16,
	Flag = "WalkSpeedValue",
	Callback = function(v)
		(getgenv()).speed = v;
	end
});
playerGroup:AddToggle({
	Name = "Toggle WalkSpeed",
	CurrentValue = false,
	Flag = "WSspeed",
	Callback = function(v)
		(getgenv()).sped = v;
	end
});
playerGroup:AddSlider({
	Name = "Set JumpPower",
	Range = {
		0,
		100
	},
	Increment = 1,
	CurrentValue = 30,
	Flag = "JumpPowerValue",
	Callback = function(v)
		(getgenv()).jump = v;
	end
});
playerGroup:AddToggle({
	Name = "Toggle JumpPower",
	CurrentValue = false,
	Flag = "JPtgl",
	Callback = function(v)
		(getgenv()).jumpy = v;
	end
});
playerGroup:AddSlider({
	Name = "Set FOV",
	Range = {
		0,
		120
	},
	Increment = 1,
	CurrentValue = tonumber((getgenv()).fov) or 70,
	Flag = "FieldOfViewValue",
	Callback = function(v)
		(getgenv()).fov = v;
		if (getgenv()).wide then
			workspace.CurrentCamera.FieldOfView = v;
		end;
	end
});
playerGroup:AddToggle({
	Name = "Toggle FOV",
	CurrentValue = false,
	Flag = "FovTgl",
	Callback = function(v)
		(getgenv()).wide = v;
		if v then
			bindFOV(workspace.CurrentCamera);
		elseif fovLockConn then
			fovLockConn:Disconnect();
			fovLockConn = nil;
		end;
	end
});
playerGroup:AddToggle({
	Name = "Infinite Jump",
	CurrentValue = false,
	Flag = "infJP",
	Callback = function(v)
		if infJumpConn then
			infJumpConn:Disconnect();
			infJumpConn = nil;
		end;
		if mobHoldConn then
			mobHoldConn:Disconnect();
			mobHoldConn = nil;
		end;
		if mobDownConn then
			mobDownConn:Disconnect();
			mobDownConn = nil;
		end;
		if mobUpConn then
			mobUpConn:Disconnect();
			mobUpConn = nil;
		end;
		if v then
			infJumpConn = UIS.JumpRequest:Connect(function()
				local h = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid");
				if h then
					h:ChangeState(Enum.HumanoidStateType.Jumping);
				end;
			end);
			if IsOnMobile and game.PlaceId == pREN then
				local h = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid");
				if h then
					h:SetStateEnabled(Enum.HumanoidStateType.Jumping, true);
				end;
				local jb = ((LocalPlayer.PlayerGui:WaitForChild("TouchControls")):WaitForChild("MobileControls")):WaitForChild("JumpButton");
				local function startHold()
					if mobHoldConn then
						return;
					end;
					mobHoldConn = RunService.Heartbeat:Connect(function()
						local mh = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid");
						if mh then
							mh:ChangeState(Enum.HumanoidStateType.Jumping);
						end;
					end);
				end;
				local function endHold()
					if mobHoldConn then
						mobHoldConn:Disconnect();
						mobHoldConn = nil;
					end;
				end;
				mobDownConn = jb.InputBegan:Connect(function(i)
					if i.UserInputType == Enum.UserInputType.Touch then
						startHold();
					end;
				end);
				mobUpConn = jb.InputEnded:Connect(function(i)
					if i.UserInputType == Enum.UserInputType.Touch then
						endHold();
					end;
				end);
			end;
		end;
	end
});
playerGroup:AddToggle({
	Name = "Auto Heal",
	CurrentValue = (getgenv()).autoHeal,
	Flag = "autoHeal",
	Callback = function(v)
		(getgenv()).autoHeal = v;
	end
});
local miscGroup = tabMain:AddGroupbox("Misc & Teleports", "hammer", "right");
miscGroup:AddButton({
	Name = "Hide Value",
	Callback = function()
		LocalPlayer.Character.Hiding.Value = not LocalPlayer.Character.Hiding.Value;
	end
});
miscGroup:AddButton({
	Name = "Teleport to Door",
	Callback = function()
		tpToDoor();
	end
});
miscGroup:AddButton({
	Name = "Teleport to Key",
	Callback = function()
		tpToKey();
	end
});
miscGroup:AddButton({
	Name = "Teleport to Lever",
	Callback = function()
		tpToLever();
	end
});
miscGroup:AddToggle({
	Name = "Auto Farm",
	CurrentValue = (getgenv()).autoFarm,
	Flag = "AutoFarm",
	Callback = function(v)
		(getgenv()).autoFarm = v;
	end
});
miscGroup:AddSection("Notifications");
miscGroup:AddInput({
	Name = "Notification Text",
	PlaceholderText = "Text",
	RemoveTextAfterFocusLost = false,
	Callback = function(t)
		(getgenv()).Notifv1 = t;
	end
});
miscGroup:AddButton({
	Name = "Send Notification",
	Callback = function()
		ObsidianUI:Notify({
			Title = "Notification",
			Content = (getgenv()).Notifv1 or "Door",
			Duration = 3,
			Image = decalID
		});
	end
});
local tabInfo = Win:AddTab("Info/Stats", "info", "Live statistics");
local L_rooms = tabInfo:AddLabel("Rooms: " .. playerRoom());
local L_bits = tabInfo:AddLabel("Bits: " .. playerBits());
local L_dbl = tabInfo:AddLabel("Double Bits: " .. doubleBits());
tabInfo:AddSection("");
local L_fame, L_deaths, L_rift, L_group;
if game.PlaceId == pREN then
	L_fame = tabInfo:AddLabel("Fame: " .. fame());
	L_deaths = tabInfo:AddLabel("Deaths: " .. deaths());
	L_rift = tabInfo:AddLabel("Rift: " .. rift());
	L_group = tabInfo:AddLabel("Joined Group: " .. inGroup());
	tabInfo:AddSection("");
end;
local L_cur = tabInfo:AddLabel("Current Room: " .. curRoom());
local L_phil = tabInfo:AddLabel("Phil Chance: " .. phil());
local L_spider = tabInfo:AddLabel("Spider Chance: " .. spider());
local L_rev;
if game.PlaceId ~= pCLASS then
	L_rev = tabInfo:AddLabel("Revive Price: " .. revivePrice());
end;
local L_alive = tabInfo:AddLabel("Players Alive: " .. alive());
local L_ingame = tabInfo:AddLabel("Players In Game: " .. inGame());
if game.PlaceId == pREN then
	tabInfo:AddSection("");
	tabInfo:AddLabel("Fuzzi: " .. fuz());
	tabInfo:AddLabel("Zav: " .. zav());
	tabInfo:AddLabel("Jake: " .. jake());
	tabInfo:AddLabel("Blue: " .. blue());
	tabInfo:AddLabel("Alan: " .. alan());
end;
local tabSettings = Win:AddTab("Settings", "cog", "UI customization");
local settingsTabRaw = tabSettings and tabSettings._tab;
if settingsTabRaw then
	local settingsMenu = settingsTabRaw:AddLeftGroupbox("Menu", "wrench");
	if settingsMenu then
		settingsMenu:AddToggle("Settings_CustomCursor", {
			Text = "Use Custom Cursor",
			Default = not (ObsidianUI.Library and ObsidianUI.Library.ShowCustomCursor == false),
			Callback = function(value)
				if ObsidianUI.Library then
					ObsidianUI.Library.ShowCustomCursor = value;
				end;
			end
		});
		settingsMenu:AddToggle("Settings_NotifySound", {
			Text = "Notification Sound",
			Default = ObsidianUI.NotifySoundEnabled ~= false,
			Callback = function(value)
				ObsidianUI.NotifySoundEnabled = value and true or false;
			end
		});
		settingsMenu:AddSlider("Settings_NotifyVolume", {
			Text = "Notification Volume",
			Default = tonumber(ObsidianUI.NotifySoundVolume) or 2,
			Min = 0,
			Max = 10,
			Rounding = 1,
			Callback = function(value)
				local num = tonumber(value);
				if num then
					ObsidianUI.NotifySoundVolume = math.clamp(num, 0, 10);
				end;
			end
		});
		settingsMenu:AddDropdown("Settings_NotifySide", {
			Text = "Notification Side",
			Values = {
				"Left",
				"Right"
			},
			Default = ObsidianUI.Library and ObsidianUI.Library.NotifySide or "Left",
			Callback = function(value)
				if ObsidianUI.Library and value then
					ObsidianUI.Library:SetNotifySide(value);
				end;
			end
		});
		local function currentDpiPercent()
			local scale = ObsidianUI.Library and ObsidianUI.Library.DPIScale or 1;
			return math.floor(scale * 100 + 0.5);
		end;
		settingsMenu:AddDropdown("Settings_DPI", {
			Text = "DPI Scale",
			Values = {
				"50%",
				"75%",
				"100%",
				"125%",
				"150%",
				"175%",
				"200%"
			},
			Default = tostring(currentDpiPercent()) .. "%",
			Callback = function(value)
				if not (ObsidianUI.Library and value) then
					return;
				end;
				local cleaned = (tostring(value)):gsub("[^%d%.]", "");
				local pct = tonumber(cleaned);
				if pct then
					ObsidianUI.Library:SetDPIScale(pct);
				end;
			end
		});
		settingsMenu:AddDivider();
		local function resolveMenuKeyDefault()
			local key = ObsidianUI.Library and ObsidianUI.Library.ToggleKeybind and ObsidianUI.Library.ToggleKeybind.Value;
			if typeof(key) == "EnumItem" and key.EnumType == Enum.KeyCode then
				return key.Name;
			elseif typeof(key) == "string" and key ~= "" then
				return key;
			end;
			return "RightControl";
		end;
		local defaultMenuKey = resolveMenuKeyDefault();
		local menuLabel = settingsMenu:AddLabel("Menu Bind");
		if menuLabel and menuLabel.AddKeyPicker then
			menuLabel:AddKeyPicker("MenuKeybind", {
				Default = defaultMenuKey,
				NoUI = true,
				Text = "Menu keybind"
			});
		end;
		settingsMenu:AddButton("Unload Script", function()
			ObsidianUI:Cleanup();
			if ObsidianUI.Library then
				ObsidianUI.Library:Unload();
			end;
		end);
	end;
	local optionsRef = ObsidianUI.Library and ObsidianUI.Library.Options;
	if optionsRef and optionsRef.MenuKeybind then
		ObsidianUI.Library.ToggleKeybind = optionsRef.MenuKeybind;
	end;
	if ObsidianUI.ThemeManager then
		ObsidianUI.ThemeManager:ApplyToTab(settingsTabRaw);
	end;
	if ObsidianUI.SaveManager then
		ObsidianUI.SaveManager:SetIgnoreIndexes({
			"MenuKeybind"
		});
		ObsidianUI.SaveManager:BuildConfigSection(settingsTabRaw);
	end;
end;
task.spawn(function()
	while task.wait() do
		pcall(function()
			L_rooms:Set("Rooms: " .. playerRoom());
			L_bits:Set("Bits: " .. playerBits());
			L_dbl:Set("Double Bits: " .. doubleBits());
			L_cur:Set("Current Room: " .. curRoom());
			L_phil:Set("Phil Chance: " .. phil());
			L_spider:Set("Spider Chance: " .. spider());
			if L_rev then
				L_rev:Set("Revive Price: " .. revivePrice());
			end;
			L_alive:Set("Players Alive: " .. alive());
			L_ingame:Set("Players In Game: " .. inGame());
			if game.PlaceId == pREN then
				L_fame:Set("Fame: " .. fame());
				L_deaths:Set("Deaths: " .. deaths());
				L_rift:Set("Rift: " .. rift());
				L_group:Set("Joined Group: " .. inGroup());
			end;
		end);
	end;
end);
trackConnection(Players.PlayerAdded:Connect(function(pl)
	task.defer(function()
		local n = pl.Name;
		local d = pl.DisplayName;
		local f = n:lower() == d:lower() and "@" .. n or d .. " (@" .. n .. ")";
		ObsidianUI:Notify({
			Title = "Player Join Log",
			Content = f .. " Joined",
			Duration = 3,
			Image = decalID
		});
	end);
end));
task.spawn(function()
	local pg = LocalPlayer:WaitForChild("PlayerGui", 5);
	if not pg then
		return;
	end;
	trackConnection(pg.DescendantAdded:Connect(function(txt)
		if not txt:IsA("TextLabel") then
			return;
		end;
		local parent = txt.Parent;
		if not parent or parent.Name:lower() ~= "hintframe" then
			return;
		end;
		local t = txt.Text:lower();
		if t:find("cannot pick that up") or t:find("you already have this") then
			task.defer(function()
				if txt and txt.Parent then
					txt:Destroy();
				end;
			end);
		end;
	end));
end);
trackConnection(Entities.ChildAdded:Connect(function(ent)
	if (getgenv()).entityEsp then
		task.defer(function()
			CreateESP(ent);
			if (getgenv()).entityNotif then
				ObsidianUI:Notify({
					Title = "Entity",
					Content = ent.Name .. " Has Spawned",
					Duration = 3,
					Image = decalID
				});
			end;
		end);
	end;
end));
trackConnection((Values.MimicActivated:GetPropertyChangedSignal("Value")):Connect(function()
	if (getgenv()).entityNotif then
		task.defer(function()
			local txt = Values.MimicActivated.Value and "Mimic Is Enabled" or "Mimic Is Disabled";
			ObsidianUI:Notify({
				Title = "Entity",
				Content = txt,
				Duration = 3,
				Image = decalID
			});
		end);
	end;
end));
trackConnection(((S("ReplicatedStorage")).Remotes:FindFirstChild("E_A", true)).OnClientEvent:Connect(function(ent)
	if (tostring(ent)):lower() == "greed" then
		task.defer(function()
			greedActive = true;
			task.wait(9);
			greedActive = false;
		end);
		if (getgenv()).entityNotif then
			ObsidianUI:Notify({
				Title = "Entity",
				Content = "Greed Spawned",
				Duration = 3,
				Image = decalID
			});
		end;
	end;
	if (getgenv()).remoteThingy then
		task.defer(function()
			ObsidianUI:Notify({
				Title = "Remote Call",
				Content = "Returned: " .. tostring(ent),
				Duration = 3,
				Image = decalID
			});
		end);
	end;
end));
trackConnection(Rooms.DescendantAdded:Connect(function(o)
	if not o:IsA("BasePart") then
		return;
	end;
	local n = o.Name:lower();
	if (getgenv()).keyESP and n == "roomkey" and o.Parent and o.Parent.Name:lower() ~= "door" then
		task.defer(function()
			CreateESP(o, Color3.new(1, 1, 0), "Key");
		end);
	elseif (getgenv()).bitESP and n == "bit" then
		task.defer(function()
			CreateESP(o, Color3.new(1, 0.666667, 0));
		end);
	elseif (getgenv()).leverESP and n == "lever" then
		task.defer(function()
			CreateESP(o, Color3.fromRGB(139, 145, 165));
		end);
	elseif (getgenv()).batteryESP and n == "battery" then
		task.defer(function()
			CreateESP(o, Color3.new(0, 0.666667, 0));
		end);
	end;
end));
local remNP = ((S("ReplicatedStorage")):WaitForChild("Remotes")):WaitForChild("NP_E");
local curRoomVal = Values:WaitForChild("RoomsNumber");
local function getChar()
	local ch = LocalPlayer.Character;
	if ch then
		return ch;
	end;
	return LocalPlayer.CharacterAdded:Wait();
end;
local function tpTo(o)
	if not o then
		return;
	end;
	local cf;
	if o:IsA("Model") then
		cf = o:GetPivot();
	elseif o:IsA("BasePart") then
		cf = o.CFrame;
	else
		local m = o:FindFirstAncestorOfClass("Model");
		if m then
			cf = m:GetPivot();
		end;
	end;
	if cf then
		(getChar()):PivotTo(cf);
	end;
end;
local function waitPlay(snd, tm)
	if not snd then
		if tm and tm > 0 then
			task.wait(tm);
		end;
		return;
	end;
	local done = false;
	local c;
	c = snd.Played:Connect(function()
		done = true;
		c:Disconnect();
	end);
	if snd.IsPlaying then
		done = true;
		c:Disconnect();
	end;
	local t0 = tick();
	local lim = tm or 10;
	while not done and tick() - t0 < lim do
		task.wait();
	end;
end;
local function imgKey(img)
	if not img or (not (img:IsA("ImageLabel") or img:IsA("ImageButton"))) then
		return nil;
	end;
	local im = img.Image or "";
	local off = img.ImageRectOffset;
	local sz = img.ImageRectSize;
	local rot = img.Rotation;
	return im .. "|" .. off.X .. "," .. off.Y .. "|" .. sz.X .. "," .. sz.Y .. "|" .. rot;
end;
local function romanNum(s)
	s = (tostring(s or "")):upper();
	if s == "" then
		return nil;
	end;
	local map = {
		I = 1,
		V = 5,
		X = 10
	};
	local t = 0;
	local prev = 0;
	for i = #s, 1, -1 do
		local ch = s:sub(i, i);
		local v = map[ch] or 0;
		if v < prev then
			t -= v;
		else
			t += v;
		end;
		prev = v;
	end;
	if t <= 0 then
		return nil;
	end;
	return t;
end;
local function findFrame(root)
	if not root then
		return nil;
	end;
	local sg = root:FindFirstChildWhichIsA("SurfaceGui", true);
	if sg then
		local fr = sg:FindFirstChild("Frame", true);
		if fr then
			return fr;
		end;
	end;
	return root:FindFirstChild("Frame", true);
end;
local function numMap(pz)
	local nr = pz:FindFirstChild("SolutionNumberReveal");
	if not nr then
		return nil;
	end;
	local fr = findFrame(nr);
	if not fr then
		return nil;
	end;
	local map = {};
	for _, ex in ipairs(fr:GetChildren()) do
		if ex.Name == "NumberExample" or ex:IsA("Frame") then
			local img = ex:FindFirstChild("ImageShape", true);
			local lbl = ex:FindFirstChild("OrderLabel", true);
			if img and lbl and lbl:IsA("TextLabel") then
				local k = imgKey(img);
				local t = tostring(lbl.Text or "");
				local d = t:match("(%d+)");
				if k and d then
					map[k] = d;
				end;
			end;
		end;
	end;
	return map;
end;
local function codeFromOrder(pz, map)
	if not map then
		return nil;
	end;
	local orv = pz:FindFirstChild("SolutionOrderReveal");
	if not orv then
		return nil;
	end;
	local fr = findFrame(orv);
	if not fr then
		return nil;
	end;
	local pos = {};
	local maxPos = 0;
	for _, ex in ipairs(fr:GetChildren()) do
		if ex.Name == "OrderExample" or ex:IsA("Frame") then
			local img = ex:FindFirstChild("ImageShape", true);
			local lbl = ex:FindFirstChild("OrderLabel", true);
			if img and lbl and lbl:IsA("TextLabel") then
				local k = imgKey(img);
				local r = tostring(lbl.Text or "");
				local p = romanNum(r);
				local d = map[k];
				if p and d then
					pos[p] = d;
					if p > maxPos then
						maxPos = p;
					end;
				end;
			end;
		end;
	end;
	if maxPos == 0 then
		return nil;
	end;
	local out = {};
	for i = 1, maxPos do
		out[i] = pos[i] or "?";
	end;
	return table.concat(out);
end;
local busyBoss = false;
local function bruteCode(room, pz)
	local gate = room:FindFirstChild("GateFinal") or room:FindFirstChild("GateFinal", true);
	local openS = gate and (gate:FindFirstChild("Opening") or gate:FindFirstChildWhichIsA("Sound", true));
	local found = false;
	local last = nil;
	local tries = 0;
	if openS then
		openS.Played:Connect(function()
			if not found then
				found = true;
				print("FOUND CODE:", last, "after", tries, "tries");
			end;
		end);
	end;
	local map = numMap(pz);
	local code = codeFromOrder(pz, map);
	if code and code ~= "" and (not code:find("%?")) then
		last = code;
		tries = 1;
		remNP:FireServer(code);
		local t0 = tick();
		while not found and tick() - t0 < 5 do
			task.wait();
		end;
		if found then
			task.wait(1);
			return;
		end;
	end;
	for i = 0, 9999 do
		if found then
			break;
		end;
		local c = string.format("%04d", i);
		last = c;
		tries += 1;
		remNP:FireServer(c);
		if tries % 10 == 0 then
			task.wait(0.1);
		end;
	end;
	if found then
		task.wait(1);
	end;
end;
local function getLeverGates(room, maxWait)
	local t0 = tick();
	local gates = {};
	repeat
		gates = {};
		for _, d in ipairs(room:GetDescendants()) do
			if d:IsA("Model") and d.Name == "LeverGates" then
				gates[(#gates) + 1] = d;
			end;
		end;
		if #gates > 0 or (not maxWait) then
			break;
		end;
		task.wait(0.25);
	until tick() - t0 >= maxWait;
	return gates;
end;
local function doBoss(room, pz)
	if busyBoss or (not (getgenv()).autoFarm) then
		return;
	end;
	busyBoss = true;
	local ls = room:FindFirstChild("LeverStart");
	if not ls then
		busyBoss = false;
		return;
	end;
	tpTo(ls);
	local pp = ls:FindFirstChildWhichIsA("ProximityPrompt", true);
	local lever = ls:FindFirstChild("Lever", true);
	local pullS = lever and (lever:FindFirstChild("Pull") or lever:FindFirstChildWhichIsA("Sound", true));
	if pp then
		task.wait(0.5);
		pcall(fireproximityprompt, pp);
	end;
	waitPlay(pullS, 10);
	task.wait(7);
	local gates = getLeverGates(room, 15);
	for _, gModel in ipairs(gates) do
		local lv = gModel:FindFirstChild("Lever", true) or gModel;
		local gpp = gModel:FindFirstChildWhichIsA("ProximityPrompt", true);
		local gsnd = lv:FindFirstChild("Pull") or gModel:FindFirstChild("Pull", true) or gModel:FindFirstChildWhichIsA("Sound", true);
		tpTo(lv);
		task.wait(0.7);
		if gpp then
			pcall(fireproximityprompt, gpp);
		end;
		waitPlay(gsnd, 6);
	end;
	local numPad = pz:FindFirstChild("NumPad") or room:FindFirstChild("NumPad", true);
	if numPad then
		tpTo(numPad);
		task.wait(3);
		bruteCode(room, pz);
	end;
	busyBoss = false;
end;
local seenBossRooms = {};
local function isBossPending()
	local n = curRoomVal.Value;
	if typeof(n) ~= "number" then
		return false;
	end;
	local r = Rooms:FindFirstChild("Room" .. n);
	if not r then
		return false;
	end;
	local rn = r:GetAttribute("RoomName");
	return typeof(rn) == "string" and rn == "ClockRoom";
end;
local function checkRoom()
	local n = curRoomVal.Value;
	if typeof(n) ~= "number" then
		return;
	end;
	if seenBossRooms[n] then
		return;
	end;
	local r = Rooms:FindFirstChild("Room" .. n);
	if not r then
		return;
	end;
	local rn = r:GetAttribute("RoomName");
	local pz = r:FindFirstChild("Puzzel") or r:FindFirstChild("Puzzle");
	if not pz and (not (typeof(rn) == "string" and rn == "ClockRoom")) then
		return;
	end;
	if not pz then
		pz = r:FindFirstChild("Puzzle") or r:FindFirstChild("Puzzel") or r;
	end;
	seenBossRooms[n] = true;
	task.spawn(function()
		doBoss(r, pz);
	end);
end;
(curRoomVal:GetPropertyChangedSignal("Value")):Connect(checkRoom);
checkRoom();
task.spawn(function()
	while true do
		if (getgenv()).autoFarm and (not busyBoss) and (not isBossPending()) then
			pcall(tpToDoor);
			task.wait(0.1);
			pcall(tpToKey);
			task.wait(0.1);
			pcall(tpToLever);
			task.wait(0.1);
		else
			task.wait(0.1);
		end;
	end;
end);
ObsidianUI:LoadConfiguration();
trackConnection(RunService.RenderStepped:Connect(function()
	if (getgenv()).chaos then
		local delay = tonumber((getgenv()).promptDelay) or 0;
		local now = tick();
		if delay <= 0 or now - lastPromptTick >= delay then
			lastPromptTick = now;
			firePrompts();
		end;
	end;
end));
cameraConn = trackConnection((workspace:GetPropertyChangedSignal("CurrentCamera")):Connect(function()
	currentCamera = workspace.CurrentCamera;
	if (getgenv()).wide then
		bindFOV(currentCamera);
	end;
end));
task.spawn(function()
	while task.wait() do
		local ch = LocalPlayer.Character;
		local h = ch and ch:FindFirstChildOfClass("Humanoid");
		if h then
			if (getgenv()).sped then
				h.WalkSpeed = (getgenv()).speed;
			end;
			if (getgenv()).jumpy then
				h.JumpPower = (getgenv()).jump;
			end;
			tryAutoHeal(h);
		end;
	end;
end);
